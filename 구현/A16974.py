# 레벨 햄버거
# DP + 재귀로 접근해야되는 문제였다.
# 난 재귀를 이용해 N 버거를 만들고 먹은 패티 갯수를 파악하려 했지만
# 이렇게 되면 N이 50인 버거를 만드는데 시간 초과가 발생한다.
# => 0과 1을 이용해 버거를 만들고 버거의 크기와 패티 갯수를 파악하지 말고 갯수만으로 점화식을 활용해 계산하자
# => 갯수만 파악하면 되기 때문에 굳이 버거를 만들 필요가 없기 때문이다.
# 문제에서 요구하는 것을 정확하게 파악하고 풀이를 생각해야 된다.
# 리스트 붙이는 방법도 숙지

n, x = map(int,input().split())
d = [0]*(n+1)
p = [0]*(n+1)
d[0] = 1
p[0] = 1

# 1 ~ n레벨 햄버거의 크기(d)와 1 ~ n레벨 햄버거 패티 개수(p) 구하기
for i in range(1, n+1):
    # d 배열: i 레벨 햄버거 크기 (햄버거번 + 패티)
    d[i] = 1 + d[i-1] + 1 + d[i-1] + 1
    # P 배열: i 레벨 햄버거 패티 개수
    p[i] = p[i-1] + 1 + p[i-1]

# n레벨 햄버거 아래 x장을 먹었을 때, 먹은 패티 개수
# 레벨 햄버거 구조 => 햄버거번 - 레벨(n-1) 버거, 패티, 레벨(n-1) 버거, 햄버거번
def go(n, x):
    # 레벨(n)이 0일때 0장을 먹으면 먹은 패티의 개수는 0개 그외는 1개
    if n == 0:
        if x == 0:
            return 0
        else:
            return 1
    elif x == 1: # 1장을 먹으면 먹은 패티의 개수는 0개
        return 0
    elif x <= 1 + d[n-1]: # 1 < 먹은 패티의 개수 <= (n-1)레벨 햄버거 크기 일때
        return go(n-1, x-1)
    elif x == 1 + d[n-1] + 1: # 먹은 패티의 개수가 햄버거 번 + (n-1)레벨 햄버거 크기 + 패티 일때
        return p[n-1] + 1
    elif x <= 1 + d[n-1] + 1 + d[n-1]: # 먹은 패티의 개수가 햄버거 번 + (n-1)레벨 햄버거 크기 + 패티 < 먹은 패티의 개수 <= 먹은 패티의 개수가 햄버거 번 + (n-1)레벨 햄버거 크기 + 패티 + (n-1)레벨 햄버거 크기 일때
        return p[n-1] + 1 + go(n-1, x-1-d[n-1]-1)
    else: # n레벨 햄버거를 다 먹었을 때
        return p[n-1] + 1 + p[n-1]

print(go(n,x))

for i in d:
    print(i)